#!/usr/bin/perl

# bugs: assumes unix file separators

use strict;
use vars qw( %OPT );
use Getopt::Long qw( GetOptions );
use IO::File;
use DirHandle;
use File::PathConvert qw( rel2abs );
use File::Basename qw( fileparse );
use Text::Forge::CGI;

sub usage {
  print STDERR "$0 [--force] [--recursive] [--template-path=] path\n";
  exit 1;
}

$| = 1;
GetOptions(\%OPT, 'force', 'recursive', 'usage|help', 'template-path=s',
                  'silent|quiet');
my @files = @ARGV;
usage if $OPT{'usage'} or !@files;

my $forge = new Text::Forge::CGI;
$forge->template_path( $OPT{'template-path'} ) if $OPT{'template-path'};
while(defined(my $file = shift @files)) {
  if (-d $file) {
    my $dh = new DirHandle $file 
      or die "unable to read directory '$file': $!";
    while(defined(my $newfile = $dh->read)) {
      next if $newfile =~ /^\.\.?$/;
      if (-d "$file/$newfile") {
        push @files, "$file/$newfile" if $OPT{recursive};
      } elsif (-f _) {
        push @files, "$file/$newfile";
      }
    }
    $dh->close;
  } elsif (-f _) {
    next unless $file =~ /\.tf$/i;
    $file = rel2abs( $file );
    my($name, $path) = fileparse( $file, '\.tf' );
    my $newfile = "$path$name.html";
    my $html = $forge->generate( $file );
    $html->header([]);
    if (-e $newfile and !$OPT{force}) {
      print "overwrite '$newfile'? ";
      chomp(my $ans = <STDIN>);
      next unless $ans =~ /^y/i; 
    }
    print "Converting '$file'... " unless $OPT{silent};
    my $fh = new IO::File "> $newfile"
      or die "unable to write '$newfile': $!";
    print $fh $html->as_string or die "error writing '$newfile': $!";
    close $fh or die "error closing '$newfile': $!"; 
    print "\n" unless $OPT{silent};
  }  
}
